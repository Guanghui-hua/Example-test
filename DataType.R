#R中的数据与数据的管理

#-------------------- R中的数据类型---------------------------------------
#数据类型 -->数值型/字符型/逻辑型/复数型/原味型(raw)???/缺省值(NA)
#查了一下，所谓原味型，就是以二进制形式保留的数据

## 如何辨别和转换数据类型，以numeric类型为例
# is.numeric()辨别函数 
# as.numeric()转换函数

## 如何查看数据的类型
# class()和demo()函数

#--------------------数据对象（储存数据的结构）----------------------------

######## 我的很重要的一个总结
# 常用的5种数据对象，基础都是向量的访问方式，
# 但是其中列表在提取元素的时候有所不同，需要list[[1]]或者 list$行名  的方式访问
# 矩阵和数组的访问方式是类似的
# 数据框的访问像是矩阵和列表的综合，两者的方式兼而有之

# R中主要的数据对象有
# 向量<矩阵<数组<数据框<列表
# 还有一种 因子(factor) 结构
# vector<matrix<array<dataframe<list
# R的数据结构中，向量、矩阵和数组的元素必须是同一类型的数据 
# 如果一个数据对象需要含有不同的数据类型，需要使用dataframe 或者 list 来容纳数据 
### 最后还有一种不是很熟悉的table对象

#=====================table类型========================================
test <- c(1,2,3,2,1,1,5,6,4,5,1)
test
#[1] 1 2 3 2 1 1 5 6 4 5 1
test1 <- table(test)
test1
#test
# 1 2 3 4 5 6   #test中的元素
# 4 2 1 1 2 1   #各个元素出现的频率
#1.提取table()中的元素
names(test1)
#[1] "1" "2" "3" "4" "5" "6"
#2.提取table()中的频率
as.numeric(test1)
#[1] 4 2 1 1 2 1
#3.进阶，提取table()中指定频率的数据，可先用as.data.frame()转换
test2 <- as.data.frame(test1)
test2
# test Freq
# 1    1    4
# 2    2    2
# 3    3    1
# 4    4    1
# 5    5    2
# 6    6    1
test2[which(test2$Freq==1),]  #提取出现频率为1的元素
# test Freq
# 3    3    1
# 4    4    1
# 6    6    1


#=========================向量(vector)类型===============================
## 单个向量中的数据类型必须相同
# 对于字符向量，一个很重要的函数paste()
paste("x",1:10,sep  = "")
## assign()函数也可以对向量进行赋值，但是注意需要对名称加上双引号，如下所示
assign("x",seq(1,10))
print(x)
#  [1]  1  2  3  4  5  6  7  8  9 10
## 如何生成序列(sequence)???
x <- 1:10
x <- seq(10,1,-1)

# 如何让一个序列重复
# req()函数

## 向量的内置函数
# 比较多，必要时可以百度

## >>>>>>>>>>>>>>>>>>>>>>>>>向量索引，访问向量<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
x <- 1:10
x[2] <- 10 #将10赋值给x向量的第2个元素
## [1]  1 10  3  4  5  6  7  8  9 10

x[c(1,3)] <- c(9,11) #把9 10 11 赋值给x的第1个到第3个元素
## [1]  9 10 11  4  5  6  7  8  9 10

x<8   #返回逻辑值
## [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE

x[x<8] #返回x中小于8的元素
## [1] 4 5 6 7

y <- c(-1,1:3,NA)
## [1] -1  1  2  3 NA

y[is.na(y)] <- 0  #把0赋值给z向量里的NA值
## [1] -1  1  2  3  0

y <- c(-1,1:3,NA)
z <- y[!is.na(y)]  #把y中的非缺失值赋值给z
## [1] -1  1  2  3

x[-(1:5)]       #删除x向量中第1到5个元素
## [1]  6  7  8  9 10

#=====================矩阵(matrix)类型===============================
## 矩阵是二维的数组，而且其单元必须是相同的数据类型
## 如何生成矩阵
## matrix(data,nrow= , ncol= ,byrow=FALSE,dimnames=NULL)
## 矩阵的常用函数，具体可以百度
## apply()函数  
# apply(X,margin,function,...)


##>>>>>>>>>>>>>>>>>>>>>>如何访问矩阵元素<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
# 可以使用A[i,j]得到A矩阵第i行第j列的元素，
# A[i,]和A[,j]分别表示返回第i行和第j列的所有元素
# 也可以使用A[i:k,j:l]的形式获得多行多列的子矩阵
A <- B <- matrix(1:12,nrow=3) #将生成的矩阵赋给A
apply(A,2,sum)  #矩阵的列求和
apply(A,1,sum)  #矩阵的行求和

#====================如何访问数组元素==============================================
#array也是元素类型必须相同
arr <- array(1:24,c(2,3,4))
arr
# , , 1
# 
# [,1] [,2] [,3] [,4]
# [1,]    1    4    7   10
# [2,]    2    5    8   11
# [3,]    3    6    9   12
# 
# , , 2
# 
# [,1] [,2] [,3] [,4]
# [1,]   13   16   19   22
# [2,]   14   17   20   23
# [3,]   15   18   21   24
arr[1,2,2]
# 表示的是第2个数据框的第1行第2列的数据
# arr[行，列，哪一个矩阵]

#======================数据框(dataframe)===========================
#数据框各列可以是不同类型的数据
#数据框可以看作是矩阵的推广，也可以看作是一种特殊的列表对象

x <- c(1,1,2,2,3,3,3)
y <- c("girl","boy","boy","girl","girl","girl","boy")
z <- c(80,85,92,76,61,95,83)
student <- data.frame(x,y,z)
student 
# x    y  z
# 1 1 girl 80
# 2 1  boy 85
# 3 2  boy 92
# 4 2 girl 76
# 5 3 girl 61
# 6 3 girl 95
# 7 3  boy 83

student <- data.frame(class=x,sex=y,score=z)
# class  sex score
# 1     1 girl    80
# 2     1  boy    85
# 3     2  boy    92
# 4     2 girl    76
# 5     3 girl    61
# 6     3 girl    95
# 7     3  boy    83
student[,3]
# [1] 80 85 92 76 61 95 83
student[,"score"] 
# [1] 80 85 92 76 61 95 83
student[1:5,1:3]   #以矩阵的形式访问

student$score   #以列表的形式访问
# [1] 80 85 92 76 61 95 83
attach(student) #以列表形式访问
score
# [1] 80 85 92 76 61 95 83
detach(student)

#=======================列表(list)===================================
# 如果一个数据对象需要含有不同的数据类型，可以采用列表(list)
# 不能使用访问矩阵的方式访问列表
###### 要使用访问列表的方式访问列表

lst <- list(class=x,sex=y,score=z)
#>>>>>>>>>>>>>>>>>>>>注意对list类型的操作和对array(matrix)有很大不同<<<<<<<<<<<<<<<<<<<<<<<
class(lst[1])
# [1] "list"
lst[1]
# $class
# [1] 1 1 2 2 3 3 3
xx <- lst[1]
xx[1]
# $class
# [1] 1 1 2 2 3 3 3
xx[1][1]
# $class
# [1] 1 1 2 2 3 3 3
xx[1][1][1]
# $class
# [1] 1 1 2 2 3 3 3
class(xx[1][1][1])
# [1] "list"
# 以上的操作都说明list是一种神奇的数据结构
# 怎么取第一个元素都还是list 
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>所以说对list类型list[1]这种操作就是xx<<<<<<<<<<<<

#正确的操作是怎么样的呢？
lst[[1]]
# [1] 1 1 2 2 3 3 3
class(lst[[1]])
# [1] "numeric"
# 感觉明明应该是一个向量类型，到最后怎么变成了数值型的了呢
lst[[2]][1:3]
# [1] "girl" "boy"  "boy"
### 另外一种操作方式
lst$sex
# [1] "girl" "boy"  "boy"  "girl" "girl" "girl" "boy" 
lst$sex[1:3]
# [1] "girl" "boy"  "boy" 
### 还可以使用attach()和detach()函数
attach(lst)
sex[1:3]
# [1] "girl" "boy"  "boy" 
score
# [1] 80 85 92 76 61 95 83
detach(lst)
score
# 错误: 找不到对象'score'


